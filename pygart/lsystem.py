"""
File: lsystem.py
Description: Turtle interpreters and L-System (grammar) generators.
"""

from math import cos, sin
from PIL import ImageDraw
from .color import solarized
from collections import deque

from random import uniform


class Turtle:
    """Turtle interpretation of grammars generated by L-Systems. """

    def __init__(self, x, y, alpha, m=1, angle_noise=None, step_noise=None):
        """(x, y, alpha) intial position and heading.  m is mirror"""
        self.x = x
        self.y = y
        self.alpha = alpha
        self.m = m
        self.stack = deque()

        if angle_noise is None:
            self.angle_noise = lambda: uniform(0, 0)
        else:
            self.angle_noise = angle_noise

        if step_noise is None:
            self.step_noise = lambda: uniform(0, 0)
        else:
            self.step_noise = step_noise

    def forward(self, d, theta=0.):
        """Step forward d along self.alpha, optionally adjusted by theta. """
        rx = self.angle_noise()
        ry = self.angle_noise()
        self.x += self.step_noise() + d * cos(self.alpha + theta + rx)
        self.y += self.step_noise() + d * sin(self.alpha + theta + ry)

    def right(self, delta):
        self.alpha += delta * self.m

    def left(self, delta):
        self.alpha -= delta * self.m

    def push(self):
        """push the current state onto the stack. """
        self.stack.append((self.x, self.y, self.alpha))

    def pop(self):
        """Restore state from the stack. """
        self.x, self.y, self.alpha = self.stack.pop()

    def __call__(self):
        return (self.x, self.y)

    def BOL(self, canvas, word, d, delta, color=solarized['base03']):
        draw = ImageDraw.Draw(canvas.img)
        for s in word:
            x, y = self()
            match s:
                case 'F':
                    self.forward(d)
                    draw.line((x, y) + self(), fill=color)
                case 'R':
                    self.forward(d)
                    draw.line((x, y) + self(), fill=color)
                    self.right(delta)
                    x, y = self()
                    self.forward(d)
                    draw.line((x, y) + self(), fill=color)
                case 'L':
                    self.forward(d)
                    draw.line((x, y) + self(), fill=color)
                    self.left(delta)
                    x, y = self()
                    self.forward(d)
                    draw.line((x, y) + self(), fill=color)
                case 'f':
                    self.forward(d)
                case '+':
                    self.right(delta)
                case '-':
                    self.left(delta)
                case '[':
                    self.push()
                case ']':
                    self.pop()


# system
def DOL(canvas, word, d, delta, turtle, color=solarized['base03']):
    draw = ImageDraw.Draw(canvas.img)

    for s in word:
        match s:
            case 'F':
                x, y = turtle()
                turtle.forward(d)
                draw.line((x, y) + turtle(), fill=color)
            case 'R':
                x, y = turtle()
                turtle.forward(d)
                draw.line((x, y) + turtle(), fill=color)
                turtle.right(delta)
                x, y = turtle()
                turtle.forward(d)
                draw.line((x, y) + turtle(), fill=color)
            case 'L':
                x, y = turtle()
                turtle.forward(d)
                draw.line((x, y) + turtle(), fill=color)
                turtle.left(delta)
                x, y = turtle()
                turtle.forward(d)
                draw.line((x, y) + turtle(), fill=color)
            case 'f':
                turtle.forward(d)
            case '+':
                turtle.right(delta)
            case '-':
                turtle.left(delta)


Koch = {'P': {'F': 'F-F+F+FF-F-F+F'}, 'axiom': 'F-F-F-F'}
KochAlt = {'P': {'F': 'F+f-FF+F+FF+Ff+FF-f+FF-F-FF-Ff-FFF', 'f': 'ffffff'},
           'axiom': 'F+F+F+F'}
Triangle = {'P': {'F': 'F+F-F-F+F'}, 'axiom': '-F'}
KochA = {'P': {'F': 'FF-F-F-F-F-F+F'}, 'axiom': 'F-F-F-F'}
KochB = {'P': {'F': 'FF-F-F-F-FF'}, 'axiom': 'F-F-F-F'}
KochC = {'P': {'F': 'FF-F+F-F-FF'}, 'axiom': 'F-F-F-F'}
KochD = {'P': {'F': 'FF-F--F-F'}, 'axiom': 'F-F-F-F'}
KochE = {'P': {'F': 'F-FF--F-F'}, 'axiom': 'F-F-F-F'}
KochF = {'P': {'F': 'F-F+F-F-F'}, 'axiom': 'F-F-F-F'}
Dragon = {'P': {'L': 'L+R+', 'R': '-L-R'}, 'axiom': 'L'}
Gasket = {'P': {'L': 'R+L+R', 'R': 'L-R-L'}, 'axiom': 'R'}


def BOL(canvas, word, d, delta, turtle, color=solarized['base03']):
    draw = ImageDraw.Draw(canvas.img)

    for s in word:
        match s:
            case 'F':
                x, y = turtle()
                turtle.forward(d)
                draw.line((x, y) + turtle(), fill=color)
            case 'R':
                x, y = turtle()
                turtle.forward(d)
                draw.line((x, y) + turtle(), fill=color)
                turtle.right(delta)
                x, y = turtle()
                turtle.forward(d)
                draw.line((x, y) + turtle(), fill=color)
            case 'L':
                x, y = turtle()
                turtle.forward(d)
                draw.line((x, y) + turtle(), fill=color)
                turtle.left(delta)
                x, y = turtle()
                turtle.forward(d)
                draw.line((x, y) + turtle(), fill=color)
            case 'f':
                turtle.forward(d)
            case '+':
                turtle.right(delta)
            case '-':
                turtle.left(delta)
            case '[':
                turtle.push()
            case ']':
                turtle.pop()


TreeA = {'P': {'F': 'F[+F]F[-F]F'}, 'axiom': 'F'}
TreeB = {'P': {'F': 'F[+F]F[-F][F]'}, 'axiom': 'F'}
TreeC = {'P': {'F': 'FF-[-F+F+F]+[+F-F-F]'}, 'axiom': 'F'}
TreeX = {'P': {'F': 'FF-[-F+F+F]+[+F-F-F]'}, 'axiom': 'F'}


def apply(n: int, system):
    '''
    Given a system (a dict with production rules and an axiom, evolve it n steps
    '''
    P = system['P']
    axiom = system['axiom']
    state = axiom
    for _ in range(n):
        next_state = ''
        for c in state:
            if c in P:
                next_state += P[c]
            else:
                next_state += c
        state = next_state
    return state
